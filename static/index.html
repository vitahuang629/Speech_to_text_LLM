<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>診所語音辨識</title>
  <style>
    body { 
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100%;
    margin: 0;
    padding: 0;
    background-image: url('static/postcard.jpeg');
    background-size: cover;
    background-repeat: no-repeat;
    background-attachment: fixed;
    background-position: center;
    font-family: sans-serif;
  }

    .button-container {
      display: flex;
      justify-content: center;
      margin-top: 1rem;
  }
    button {
    padding: 1rem 2rem;
    font-size: 1.2rem;
    margin: 1rem;
  }
    h1 {
      text-align: center;
  }
    #transcript { 
      margin-top: 2rem; 
      font-size: 1.5rem; 
      white-space: pre-wrap;
      display: none; /* 隱藏即時辨識文字 */
  }
    #summaryResult { 
    margin-top: 2rem;
    font-size: 1.5rem;
    white-space: pre-wrap;
    display: none;
    background-color: transparent;
    border: none;
    color: #222;
    max-width: 90%;
    max-width: 800px;
    text-align: center;
  }
    .loading {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(0,0,0,.3);
    border-radius: 50%;
    border-top-color: #000;
    animation: spin 1s ease-in-out infinite;
  }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* 音訊動畫樣式 */
    #audioAnimation {
      margin-top: 2rem;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      display: none;
    }
    .audio-bar {
      display: inline-block;
      width: 8px;
      height: 30px;
      margin: 0 4px;
      background-color: #4CAF50;
      border-radius: 4px;
      animation: audio-wave 1.2s ease-in-out infinite;
    }
    .audio-bar:nth-child(2) { animation-delay: 0.1s; }
    .audio-bar:nth-child(3) { animation-delay: 0.2s; }
    .audio-bar:nth-child(4) { animation-delay: 0.3s; }
    .audio-bar:nth-child(5) { animation-delay: 0.4s; }
    
    @keyframes audio-wave {
      0%, 100% { height: 30px; }
      50% { height: 60px; }
    }
    
    .status-text {
      margin-top: 1rem;
      font-size: 1.2rem;
      color: #666;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>🎙️ 即時語音辨識 </h1>
  <button id="startBtn">開始辨識</button>
  <button id="stopBtn" disabled>停止辨識</button>
  
  <!-- 音訊動畫 -->
  <div id="audioAnimation">
    <div class="audio-bar"></div>
    <div class="audio-bar"></div>
    <div class="audio-bar"></div>
    <div class="audio-bar"></div>
    <div class="audio-bar"></div>
  </div>
  <div id="statusText" class="status-text">準備就緒，請點擊「開始辨識」</div>
  
  <!-- 隱藏的即時辨識文字區域 -->
  <div id="transcript">辨識文字將顯示在此...</div>
  
  <!-- 只保留摘要結果區域 -->
  <div id="summaryResult"></div>
  <button id="copyBtn" style="display: none;">📋 複製摘要</button>

  <script>
    let websocket;
    let audioContext;
    let processor;
    let input;
    let stream;
    let sessionId = null; // 儲存會話ID

    const transcriptDiv = document.getElementById("transcript");
    const summaryResultDiv = document.getElementById("summaryResult");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const audioAnimation = document.getElementById("audioAnimation");
    const statusText = document.getElementById("statusText");

    const copyBtn = document.getElementById("copyBtn");

    copyBtn.onclick = () => {
      const summaryText = summaryResultDiv.innerText.replace(/^📋 LLM摘要：\n/, "");
      navigator.clipboard.writeText(summaryText).then(() => {
        copyBtn.innerText = "✅ 已複製！";
        setTimeout(() => copyBtn.innerText = "📋 複製摘要", 1500);
      }).catch(err => {
        console.error("複製失敗：", err);
        copyBtn.innerText = "❌ 複製失敗";
      });
    };

    startBtn.onclick = async () => {
      startBtn.disabled = true;
      stopBtn.disabled = false;
      transcriptDiv.innerText = ""; // 清空辨識文字
      summaryResultDiv.style.display = "none";
      
      // 顯示音訊動畫
      audioAnimation.style.display = "flex";
      statusText.innerText = "正在錄音並辨識...";
      
      sessionId = null; // 重置會話ID

      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (err) {
        statusText.innerText = "❌ 無法取得麥克風權限，請確認瀏覽器設定及權限";
        startBtn.disabled = false;
        stopBtn.disabled = true;
        audioAnimation.style.display = "none";
        return;
      }

      // 這裡用 ws:// 或 wss:// 看你的網站是 http 還是 https
      const wsProtocol = window.location.protocol === "https:" ? "wss://" : "ws://";
      websocket = new WebSocket(wsProtocol + window.location.host + "/ws/asr");
      // 這裡改成固定連到 FastAPI 的 port 8000
      // const wsProtocol = window.location.protocol === "https:" ? "wss://" : "ws://";
      // websocket = new WebSocket(wsProtocol + "localhost:8000" + "/ws/asr");

      websocket.onopen = () => {
        statusText.innerText = "麥克風已啟動，正在辨識中...";
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });

        input = audioContext.createMediaStreamSource(stream);
        processor = audioContext.createScriptProcessor(4096, 1, 1);

        processor.onaudioprocess = (e) => {
          const inputData = e.inputBuffer.getChannelData(0);
          const pcm = convertFloat32ToInt16(inputData);
          if (websocket.readyState === WebSocket.OPEN) {
            websocket.send(pcm);
          }
        };

        input.connect(processor);
        processor.connect(audioContext.destination);
      };

      websocket.onmessage = (event) => {
        try {
          // 嘗試解析JSON格式
          const data = JSON.parse(event.data);
          if (data.type === "session_id") {
            // 儲存會話ID
            sessionId = data.session_id;
            console.log("收到會話ID:", sessionId);
          }
        } catch (e) {
          // 如果不是JSON格式，則為一般辨識結果
          const text = event.data;
          transcriptDiv.innerText += "\n" + text;
          // 不顯示即時辨識文字，但仍然記錄
        }
      };

      websocket.onerror = (event) => {
        statusText.innerText = "WebSocket 連線錯誤";
        console.error("WebSocket error:", event);
      };

      websocket.onclose = () => {
        statusText.innerText = "WebSocket 已關閉";
      };
    };

    // stopBtn.onclick = async () => {
    //   startBtn.disabled = false;
    //   stopBtn.disabled = true;

    //   // 隱藏音訊動畫
    //   audioAnimation.style.display = "none";
    //   statusText.innerText = "辨識已停止，正在生成摘要...";

    //   if (processor) processor.disconnect();
    //   if (input) input.disconnect();
    //   if (audioContext) audioContext.close();
      
    //   // 關閉主要的語音辨識 WebSocket
    //   if (websocket) websocket.close();
    //   if (stream) stream.getTracks().forEach(track => track.stop());

    //   // 如果有會話ID，使用REST API取得最終辨識結果
    //   if (sessionId) {
    //     try {
    //       // 顯示等待中的提示
    //       summaryResultDiv.innerHTML = "📋 對話摘要：<div class='loading'></div>";
    //       summaryResultDiv.style.display = "block";
          
    //       // 等待一小段時間，確保後端已處理完畢
    //       setTimeout(async () => {
    //         try {
    //           const response = await fetch(`/api/final-result/${sessionId}`);
    //           //const response = await fetch("http://localhost:8000/api/final-result/" + sessionId);
    //           const data = await response.json();
    //           print(data.type)
              
    //           if (data.type === "final_result") {
    //             // 不顯示最終辨識結果，只顯示LLM摘要
                
    //             // 顯示LLM摘要
    //             if (data.summary && data.summary !== "正在生成摘要...") {
    //               summaryResultDiv.innerHTML = "📋 LLM摘要：\n" + data.summary;
    //               statusText.innerText = "摘要已生成完成";
    //               copyBtn.style.display = "inline-block";
    //             } else {
    //               summaryResultDiv.innerHTML = "📋 LLM摘要：\n正在生成摘要...";
    //               statusText.innerText = "正在生成摘要...";
                  
    //               // 如果摘要還沒準備好，定期檢查
    //               let checkCount = 0;
    //               const checkSummary = async () => {
    //                 if (checkCount >= 10) { // 最多檢查10次
    //                   summaryResultDiv.innerHTML = "📋 LLM摘要：\n摘要生成超時，請稍後再試";
    //                   statusText.innerText = "摘要生成超時";
    //                   return;
    //                 }
                    
    //                 try {
    //                   const summaryResponse = await fetch(`/api/final-result/${sessionId}`);
    //                   const summaryData = await summaryResponse.json();
                      
    //                   if (summaryData.type === "final_result" && summaryData.summary && summaryData.summary !== "正在生成摘要...") {
    //                     summaryResultDiv.innerHTML = "📋 LLM摘要：\n" + summaryData.summary;
    //                     statusText.innerText = "摘要已生成完成";
    //                   } else {
    //                     checkCount++;
    //                     statusText.innerText = `正在生成摘要...（${checkCount}/10）`;
    //                     setTimeout(checkSummary, 1000); // 每秒檢查一次
    //                   }
    //                 } catch (e) {
    //                   console.error("檢查摘要時出錯:", e);
    //                   summaryResultDiv.innerHTML = "📋 LLM摘要：\n獲取摘要時出錯";
    //                   statusText.innerText = "獲取摘要時出錯";
    //                 }
    //               };
                  
    //               setTimeout(checkSummary, 2000); // 2秒後開始檢查
    //             }
    //           } else if (data.type === "pending") {
    //             // 結果還沒好，繼續輪詢
    //             checkCount++;
    //             statusText.innerText = `正在生成摘要...（${checkCount}/10）`;
    //             setTimeout(checkSummary, 1000);                        //7/3
    //           } else if (data.type === "error") {
    //             console.error("取得最終結果時出錯:", data.message);
    //             summaryResultDiv.innerHTML = "1❌ 取得摘要時出錯";
    //             statusText.innerText = "取得摘要時出錯";
    //           }
    //         } catch (e) {
    //           console.error("取得最終結果時出錯:", e);
    //           summaryResultDiv.innerHTML = "2❌ 取得摘要時出錯";
    //           statusText.innerText = "取得摘要時出錯";
    //         }
    //       }, 1000); // 等待1秒
    //     } catch (e) {
    //       console.error("取得最終結果時出錯:", e);
    //       summaryResultDiv.innerHTML = "3❌ 取得摘要時出錯";
    //       statusText.innerText = "取得摘要時出錯";
    //     }
    //   }
    // };

        // ==================== 複製並替換這個完整的函數 ====================
    stopBtn.onclick = async () => {
      startBtn.disabled = false;
      stopBtn.disabled = true;

      // 隱藏音訊動畫
      audioAnimation.style.display = "none";
      statusText.innerText = "辨識已停止，正在生成摘要...";

      // 清理資源
      if (processor) processor.disconnect();
      if (input) input.disconnect();
      if (audioContext) audioContext.close();
      if (stream) stream.getTracks().forEach(track => track.stop());
      
      // 關閉 WebSocket 連線
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.close();
      }

      // 如果沒有 session ID，就無法查詢結果，直接結束
      if (!sessionId) {
        statusText.innerText = "錯誤：未取得有效的會話 ID";
        return;
      }

      // --- 開始執行新的輪詢邏輯 ---
      getFinalResultWithPolling(sessionId);
    };

    /**
     * 帶有輪詢機制的函數，專門用來獲取最終結果。
     * @param {string} sessionId - 要查詢的會話 ID。
     */
    async function getFinalResultWithPolling(sessionId) {
      const maxRetries = 15; // 最多重試 15 次
      const retryInterval = 2000; // 每次重試間隔 2 秒

      summaryResultDiv.innerHTML = "📋 正在生成摘要... <div class='loading'></div>";
      summaryResultDiv.style.display = "block";
      copyBtn.style.display = "none";

      for (let i = 0; i < maxRetries; i++) {
        try {
          const response = await fetch(`/api/final-result/${sessionId}`);
          //7/9
          if (response.status === 404) {
            console.warn(`❌ 後端回應 404，代表結果不存在或已被清理，停止輪詢`);
            statusText.innerText = `找不到結果，請重新辨識`;
            summaryResultDiv.innerHTML = "❌ 找不到結果，可能已過期或不存在";
            copyBtn.style.display = "none";
            return; // ✅ 停止輪詢！
          }

          if (!response.ok) {
            // 處理 HTTP 錯誤，例如 500 Internal Server Error
            throw new Error(`伺服器回應錯誤，狀態碼: ${response.status}`);
          }

          const data = await response.json();

          // 根據後端回傳的 type 進行判斷 //這段原先是string的時候
          // if (data.type === "final_result") {
          //   console.log("✅ 成功取得最終結果:", data);
            
          //   // 將摘要中的換行符 \n 替換為 HTML 的 <br> 標籤以便正確顯示
          //   const formattedSummary = data.summary.replace(/\n/g, '<br>');
          //   summaryResultDiv.innerHTML = "📋 LLM摘要：<br>" + formattedSummary;
            
          //   statusText.innerText = "摘要已生成完成";
          //   copyBtn.style.display = "inline-block"; // 顯示複製按鈕
          //   return; // 成功，結束輪詢
          // }

          if (data.type === "final_result") {
            console.log("✅ 成功取得最終結果:", data);

            // 如果 summary 是 object，就先格式化成漂亮的文字
            let formattedSummary = "";
            if (typeof data.summary === "object") {
              for (const [key, value] of Object.entries(data.summary)) {
                formattedSummary += `【${key}】: ${value}<br>`;
              }
            } else {
              // fallback 如果是 string
              formattedSummary = data.summary.replace(/\n/g, '<br>');
            }

            summaryResultDiv.innerHTML = "📋 LLM摘要：<br>" + formattedSummary;
            statusText.innerText = "摘要已生成完成";
            copyBtn.style.display = "inline-block"; // 顯示複製按鈕
            return; // 成功，結束輪詢
          }
          
          // 如果 type 是 "pending" 或 "error"，我們都視為需要重試
          // 因為 "error" 很可能只是後端還沒來得及寫入資料
          console.log(`⏳ 結果尚未就緒 (類型: ${data.type})，將在 ${retryInterval / 1000} 秒後重試...`);
          statusText.innerText = `摘要生成中... (嘗試 ${i + 1}/${maxRetries})`;

        } catch (error) {
          // 處理網路錯誤或 JSON 解析錯誤
          console.error(`獲取結果時發生錯誤 (第 ${i + 1} 次嘗試):`, error);
          statusText.innerText = `網路或連線錯誤，正在重試... (嘗試 ${i + 1}/${maxRetries})`;
        }

        // 等待指定時間後再進行下一次迴圈
        await new Promise(resolve => setTimeout(resolve, retryInterval));
      }

      // 如果迴圈跑完還沒拿到結果，就顯示超時錯誤
      console.error("❌ 超過最大重試次數，無法取得摘要。");
      summaryResultDiv.innerHTML = "❌ 取得摘要時出錯 (超時)";
      statusText.innerText = "取得摘要失敗";
      copyBtn.style.display = "none";
    }
    // =================================================================

    function convertFloat32ToInt16(buffer) {
      const l = buffer.length;
      const result = new Int16Array(l);
      for (let i = 0; i < l; i++) {
        const s = Math.max(-1, Math.min(1, buffer[i]));
        result[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return result.buffer;
    }
  </script>
</body>
</html>
